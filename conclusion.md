# 网络基础知识

本章节的内容注重实际应用，通过讲解在用户从浏览器地址栏输入网址到浏览器渲染出页面的过程中发生了什么来穿插学习内容，达到学习以后可以掌握在开发中熟练使用 HOST 代理和抓包分析的目的。

### 一个最普通的请求的概览

#### HOST和DNS

我们来用一个图看看一个最普通的请求是怎么发生的。

由于我们的互联网是基于TCP/IP来构建的，所以浏览器在输入域名之后，其实浏览器并不知道你想访问的服务器到底是网络上的哪个设备，它必须要去找到这个域名对应的IP地址，然后把请求发送到这个IP地址上。

如图：浏览器查询域名与IP地址关系的服务器叫做DNS服务器，该服务器没有域名，直接以IP地址的形式保存在用户计算机的配置里面。

就这样吗？那原来还没有发明DNS服务器的时候，人们是怎么访问互联网的？

原来，在那时，人们维护一个叫做HOST的文件，在这个文件中，记录了当时为数不多的域名和它们对应IP的关系。（那么肯定有一些IP没有域名，那我们怎么访问它呢？我们可以通过在浏览器中直接输入IP地址的方式访问它们）

但是随着拥有域名的站点越来越多，大家的HOST文件都无法保证 1）同步更新，2）收录最新最完整的列表。这个时候有这么一种想法，能不能把这些HOST放到固定IP上，大家都去这个固定IP请求该文件呢？甚至，我们可不可以不请求整个庞大的文件，而是只让它告诉自己想要访问那个域名的IP就行了呢？这个就是我们现在DNS服务器的原理：我们让它告诉我们需要访问的域名的IP地址。我们就这样成功的把本地冗长的HOST文件移动到了一个公共服务器上。

虽然每个电脑本地的HOST文件的内容都没有了，但是这个机制还是留存着：操作系统会先去本地HOST查询域名，如果查到了，直接访问；如果没有查到，再去远程DNS查询。

理解了以上的内容我们来看看我们要学会的第一个技能：作为一个开发者，我们假如仍然想用真实的域名`welkin.online`去访问我们的开发机器上面的服务器`10.10.10.1`，那我们应该如何做呢？或者我们需要把一个开发用的域名如 `dev.welkin.online`绑定到自己开发用的机器`10.10.10.1`上呢？有多种方式：1）我们可以修改想要用来访问的计算机的HOST文件，让该域名指向开发机器；2）我们可以自己搭建DNS服务器，让想要访问的计算机的DNS设置为这个DNS服务，然后在DNS服务中将开发机器的IP与想要访问的域名进行绑定。

现在我们开始了手机页面的开发，这个时候我们想要用手机真机来调试，我们却发现，在现在的iOS手机上，我们是没有权限访问到HOST文件的。那我们只剩下自建一个DNS服务器了？其实并不是的，接下来我们来学习一种新的方式-**代理**

#### 什么是代理

代理就是用户A把所有的请求都通过一个外界的服务器B来完成对一些网站C的请求。从被请求的网站C来看，所有的请求就是来自B的IP，而不是A。那么这个和我们将手机的请求定位到开发机器上有什么关系呢？我们可以这么看看。在B服务器的HOST中将开发机器和相应域名绑定，这样被代理过来的流量走到B机器的时候，也会查询这个HOST，这样就能达成手机访问开发机器了。

PS：这个代理过程也可以全部发生在手机上，即AB都是我们的手机。有一些调试和代理iOS app，可以将手机所有的流量接管并且代理到指定的机器上，也可以在该APP内部将流量分流，将`dev.welkin.online`直接指向开发机器`10.10.10.1`如图：

#### 知识点总结

1. DNS服务：
2. HOST文件：

#### 课后思考题

```
1 在各大操作系统上，HOST文件都在什么目录？该文件的用户组权限是什么？
2 DNS协议的默认端口是什么？如何自己架设一个DNS服务器
3 画出代理模式的网络请求图
```


### 协议(protocol)、域名(host)、路径(path)、搜索(query)、请求方法(method)和头部字段

我们来看看在浏览器输入的内容：

http://welkin.online:8080/2017/05/?comment=0

以上的内容我们称作 URL 或者 URI （URL 和 URI的区别我们会附在结尾）。

我们来看看发出去的请求，用`plain text`来看是什么样的：

```http
GET /2017/05/?comment=0 HTTP/1.1
Host: welkin.online
Connection: Close
User-Agent: Paw/3.1.1 (Macintosh; OS X/10.12.5) GCDHTTPRequest
```

这个请求内容第一行的单词就是**请求方法**，这里我们使用了`GET`方法来请求资源；第一行方法后面的就是**请求路径**和**搜索**，我们在这里请求了`/2017/05/`这个路径的资源，并且给出了`comment=0`这个搜索条件；之后的行数里面都是头部字段，我们可以看到第二行是Host字段，第三行是Connection字段，第四行是User-Agent字段。下面我们来分析一下这几个要素：

#### 协议

这里的协议就是 `http://`。我们首先建立一个协议的概念：什么是协议？协议就是双方协定好了的一种数据的表达、通信或者编码方式。比如我们在桌面上新建一个空白的`.html`文件，然后右键使用浏览器打开，这个时候我们还会看到`http://`开头的协议吗？不会，我们会看到`file://`开头的协议，这就是`file`协议。那如果我们在浏览器地址栏中输入其他的协议呢？比如`smb://`,`ssh://`,`ftp://`会怎么样呢？

截图：

`smb://`,`ftp://`这两个协议都会弹窗提示我们是否打开`Finder.app`，而`ssh://`则会问我们是否要打开`终端.app`。**由此我们可知道在操作系统里面，不同的协议种类是对应到了不同的客户端软件的。**而网络浏览器主要对应的协议就是`http://`和`https://`（当然，也可以支持`file://`协议）。

而我们使用的HTTP协议，是一个文本传输协议（Hyper Text Tranfer Protocol），它直接传输文本内容，并且不保留客户端协议。

#### 域名

这里的主机名就是 `welkin.online`。它的作用是什么？由于使用互联网的用户越来越多我们的IP地址变得非常紧张，有的时候，我们不得不把好几个网站共享一个IP地址（即同一个物理服务器），这个时候我们把每个网站称为一个`虚拟主机`而把物理服务器称为`服务器`，然后使用诸如`nginx`来作为一个`http`服务软件。而域名在这里面除了能给DNS以查询IP的功效之外，还需要放在HTTP请求里面（host头字段中）方便服务器上的程序区分该请求究竟是请求该物理主机上哪个虚拟主机的。

#### 路径

这里的路径就是 `/2017/05/`，这里是告诉http服务器我们想要访问的文件基于网站根目录的位置。假设在Linux服务器上，网站的根目录是 `/www/`，那么我们在这里访问的目录就是`/www/2017/05/`。后来我们有了PHP等后端程序，这个时候，目录也可以并不真实存在，而是变成了`路由`。

#### 搜索

这里的搜索就是 `comment=0`，这个搜索是完全交给后端程序处理的。比如我们传递了一个`comment=0`，那么后端PHP程序就会去找这些博文中，评论数量等于0的返回。这个方法在 HTTP协议 0.9 版本的时候，是向后端传递信息的唯一方法，因为 HTTP 0.9 仅支持`GET`方法，并且不支持头部字段。 

#### 请求方法

请求方法，也叫做**HTTP动词**或者**HTTP谓词**我们这次请求是通过`GET`方法来请求的。那么是不是只有`GET`这种方法了呢？当然不是，常见的HTTP方法和它们的操作如下：

```
GET: 从服务端获取一个资源（不对对服务端的数据做修改）
POST:在服务端新建一个资源（会在服务端的数据新增记录）
PUT: 更新服务端的一个资源（会修改服务端的数据）
HEAD:只返回GET方法的头部
OPTION:询问服务端支持哪些HTTP方法
DELETE:将资源从服务端删除
```

而我们最常用的请求方法就是`GET`和`POST`方法。一般情况下，我们使用GET方法从服务端获取资源，如`HTML`文件，`CSS`文件，`JS`文件。而使用`POST`方法来传递一些表单给服务端。

##### 常见的误用

我们经常可以看见有的开发者在`GET`方法的搜索中传递参数（这很可能是从 HTTP 0.9 时代带来的坏习惯），以至于习惯了之后竟然将用户名和密码的明文通过`GET方法`来传输，造成严重的泄密事件。

我们来辨析一下这两个方法在传递参数时候的同异：

`GET`方法：参数直接写在URL中，通过URL query（搜索）来传递参数，在某些浏览器上会有长度限制，且传递的参数会在途经的路由设备上的日志记录下来，如果传递用户名等敏感信息会导致信息被截获的风险加大。

`POST`方法：参数写在请求的body中，可以传输的信息长度比`GET`方法要长，不会存在被路由设备记录下信息的风险。

##### 课外思考

Q：既然不能明文传输，那我们应该怎么处理用户登录的账号和密码呢？（答案见课程最后）


#### 头部字段

每一个请求都有头部字段，比如：Host，或者 Connection。头部字段附带了一些详细信息，比如用户想要访问的域名，或者本次访问的连接类型，或者用户使用的浏览器类型。更多关于HTTP头字段的信息可以在[维基百科](https://zh.wikipedia.org/wiki/HTTP头字段列表)中找到。在后面我们还会继续提到这个话题，所以这里就先不详细展开。

#### 小结

协议 -> 客户端与服务端协定的通信方式。

域名 -> 告知服务端的`http`服务软件我们访问的具体是哪个虚拟主机

路径 -> 告知后端程序我们想要访问的文件路径（该路径可以不存在，只要后端程序可以处理即可）

搜索 -> 告知后端程序我们想要查询的一个内容，后端程序进行计算后返回结果。

请求方法 -> 告知服务端我们想要进行的操作

### 请求发送到服务器之后发生了什么呢？

首先我们看看服务端的返回是什么样的：

```http
HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sun, 28 May 2017 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.welkin.online
Connection: keep-alive

<html>
	<head>
	</head>
	<body>
		Hello, world!
	</body>
</html>
```

这段返回的前面几行怎么看着这么眼熟呢？是不是和请求的头特别像？没错，这个就是`响应头`，第一行包括了HTTP版本和`HTTP状态码（HTTP Status Code）`（更多内容更可以参考[wikipedia](https://zh.wikipedia.org/wiki/HTTP状态码)），最后是`HTTP状态码信息`。

#### HTTP返回头

服务端返回的文件的头几行一直到第一个空行为止，都是HTTP返回头。它包含了一些必要的信息。它也由头行和后面跟随的HTTP头字段构成。头行包括HTTP协议版本，HTTP状态码，状态码信息。

##### HTTP状态码

HTTP状态码`的一些常见数值：

###### 1xx消息：

一般此类消息表示服务端已经收到了客户端的请求，需要继续处理。一般这个是临时响应。

###### 2xx成功：

表示请求已经被客户端成功接受并且处理。常见的有`200 OK`、`201 Created`、`202 Accepted`

###### 3xx重定向：

表示资源已经变更，需要客户端进一步操作，常见的有`301 Moved Permanently`、`302 Found`

###### 4xx客户端错误：

表示客户端的请求有问题，常见的有`400 Bad Request`、`401 Unauthorized`、`403 Forbidden`、`404 Not Found`、`405 Method Not Allowed`、`408 Request Timeout`

###### 5xx服务端错误：

表示服务端发生了错误，常见的有`500 Internal Server Error`、`502 Bad Gateway`、`503 Service Unavailable`、`504 Gateway Timeout`

以上只是列举了一些常见的状态码，更多详细的信息可以参考[维基百科](https://zh.wikipedia.org/wiki/HTTP状态码)

##### HTTP响应头字段

响应头的头字段也是用来描述一些不需要直接放到响应体中的信息。比如服务端使用的软件，或者响应的长度（字节数），但是最值得说的就是`Set-Cookie`字段（还有即将提到的`ETag`字段）：`Set-Cookie`是为了给HTTP这个**无状态协议**加上状态而提出来的一个内容。服务端在这里告诉客户端：“hi，下次你请求新资源的时候带上这个，我就认得你啦！”而客户端下次请求的时候带上了`Cookie: cookieFromServer`，就能让服务端辨识出自己的身份了。

那么`ETag`字段又是干什么的呢？这个字段反映了对于某个资源的某个特定版本的一个标识符，只要客户端发现了这个标识符没有发生变化，就不会再次和服务端请求这个资源，是我们用来提速的一个好东西。（后续在缓存策略中会有提及）。

那么回归正题，请求在服务器中，究竟是怎么走的呢？

#### 网页服务器和后端程序

网络请求打到服务器上之后，（如果是在网页服务器监听的端口上，比如80端口，的时候）首先会经过网页服务器，如果没有经过网页服务器监听的端口，那这个请求就会直接进入那个端口（比如说8080端口），如果这个端口是由后端服务器（如PHP，node.js）开启的，那个这些请求就会直接发送给后端程序。而进入网页服务器的请求，会按照网页服务器的配置来进行分流（如果在网页服务器上托管了多个后端程序，即托管了多个**虚拟主机**）

##### 小问题：为什么要使用HTTP服务器呢？或者说，它的好处在哪里呢？

##### 必备技能：

在平时开发中，如何学会给错误返回除错？

首先，我们要学会看请求是怎么被处理的。也就是说，这个请求究竟是首先被网页服务器处理了，还是直接发送到了后端程序？其次，我们再去看网页服务器和后端程序的日志文件。

一个典型的NGINX配置文件：

```nginx
#user  nobody;
worker_processes  1;

error_log   /usr/local/var/log/nginx/nginx_error.log;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;
  	access_log  /usr/local/var/log/nginx_http_access.log;
    error_log   /usr/local/var/log/nginx_http_error.log; # debug;
    sendfile        on;
	keepalive_timeout  65;

    gzip  on;

    server {
        listen       80;
        server_name  welkin.online;

        charset utf-8;

        access_log  /usr/local/var/log/nginx/welkin.online.access.log; #  main;
        error_log   /usr/local/var/log/nginx/welkin.online.access.log; #  main;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Nginx-Proxy true;
		}

        location /login {
            root   html;
            index  index.html index.htm;
        }
    	error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
  	}
}

```

我们需要注意的是nginx整体的`error_log`位于`/usr/local/var/log/nginx/nginx_error.log;`，`welkin.online`的`access_log` 位于  `/usr/local/var/log/nginx/welkin.online.access.log`，`error_log`位于`/usr/local/var/log/nginx/welkin.online.access.log`。当我们排查问题的时候就可以按照这样的顺序去排查问题。

#### 服务器返回一个`HTML`文件

从上面的响应来看，服务器返回的仅仅是一个`HTML`文件，那么网站里面的`CSS`和`JS`文件都是什么时候被返回到浏览器的呢？让我们跟随这串`HTML`信息的比特流返回到客户端看看究竟。

#### 浏览器的解析和渲染过程

##### DOM树，样式表对象和渲染树

随着电位变化的传递，我们跟随着HTML文件来到了客户端。浏览器一听到`HTML`文件来了就开始了**HTML解析过程（HTML Parse）**，解析过程生成的产物叫做`DOM树`。在这个过程中，遇到了`link`标签的样式文件，浏览器就会调动一个下载线程去下载和解析这个样式文件（下载和解析CSS文件不会阻塞HTML的解析过程），CSS的解析产物叫做`样式表对象`。而遇到了`script`标签的时候，浏览器却会**停止**HTML解析过程，转而去下载和执行script标签的脚本文件。这又是为什么呢？

```
如图，JS的加载之所以影响HTML的解析，是因为有DOM API的存在，哪怕HTML都解析完了，在最后的脚本中调用 document.write 方法也会重写页面内容，为了优化这样的情况，浏览器决定在碰到script标签的时候一定要先下载并且执行完脚本才继续HTML的解析过程。而CSS文件的下载，虽然不会影响HTML的解析和JS的下载，却会影响JS的执行。这是因为JS中有一些DOM操作是依赖CSS的，比如使用JS给获取某个DOM元素的宽度，那么首先这个DOM元素得有宽度，而很多时候DOM元素的宽度是从CSS中来的。
```

在我们的`DOM树`和`样式表对象`都生成之后（再次注意`DOM树`的构建，JS脚本也会参与），由他们两再合并成`渲染树`，浏览器再通过`渲染过程`，把渲染树显示到屏幕上。从流程上来说，只要生成了新的渲染树，就会再次触发`渲染过程`，因此，使用JS来改变某个DOM元素的样式，是会重新生成`样式表对象`和`渲染树`的。

##### 从原理到性能

到`渲染过程`结束，我们大概的走了一遍从将地址输入到浏览器地址栏到最终页面在浏览器中显示出来背后发生的事情。那么我们的开发也是围绕这些展开的。接下来我们讲讲围绕性能，我们有哪些必知的。

###### CDN-内容分发网络

假如我们的样式表，JS脚本都存放在北京的机房中，对于美国的用户来说，他首先需要从这个机房的服务器获取到HTML文件，然后在HTML的解析过程中发现CSS和JS文件，他不得不继续向北京的机房请求这些文件，让我们来算算时间吧：

北京到纽约的直线距离为16000KM，以光纤为例，假设折射率为1.5，那么往返一趟的时间为 16000KM/299 792 458 (m / s) / 1.5 = 35.58ms。以请求为例，一个请求至少需要3次握手，3次握手也就是 35.58*3 = 106.74ms。也就是说每个文件至少需要100ms来加载（这是最好情况！）。假设有3个CSS文件，那么除了加载HTML文件外，浏览器还需要300ms额外时间尝试从北京机房下载静态资源到本地。

那我们如果想要用户得到的响应更快，是不是应该拿出一些方法来？于是就有了 CDN 。CDN 将 CSS 、 JS 这些静态文件（为什么叫做静态文件是因为与可能是后端程序生成的HTML不同的是这些文件在开发的时候就被开发者写出来了）放到用户身边的机房去。

CDN的一些展开：缓存策略和CDN（要开始填HTTP响应头字段那里埋下的坑了，我们再回想一下，在HTTP头字段的时候，我们提到了一个叫做`ETag`的头字段，表明它是对文件的一个标识符，只要标识符不变，就可以用本地的缓存）。那我们来看看 CDN 和缓存的一些联想吧？

从速度上来说缓存比 CDN 更快，哪怕是 CDN 也需要花费3次握手去获取文件，而缓存可以直接从用户的磁盘里面读取文件。那这又能怎么样呢？反正浏览器都花时间去请求远程的资源了（要不然就拿不到`ETag`字段）。但是如果考虑到是一个大的文件，三次往返并不一定能拿到所有的内容，这个时候从缓存拿文件显然更加快。

而针对CDN的一些优化更有意思：比如在打包页面的时候，将所有的第三方库独立打包，将页面逻辑JS也独立打包，这样生成了两个JS文件，然后给库命名为 `lib.{libhash}.js` ，而逻辑文件命名为 `main.js`，并且在HTML中写成 `main.js?v={packTime}`这样能更好的利用CDN和缓存。下面我们来解析一下这两种明明方法的区别。

CDN在收到一个请求的时候，会首先看看自己的机器上有没有这个资源的快照，如果没有就向上游请求该文件。比如 `main.js?v=201705`这个资源，假如CDN只有 `main.js?v=201704` 这个快照，那么他就会认定需要到上游请求一下 `main.js?v=201705`这个资源。这样的话，只要我们改动了 HTML 文件中`main.js`后面的`v=`参数即可强制CDN刷新静态资源文件。而`lib.{libhash}.js`则是为了充分利用缓存而进行的策略。浏览器在收到要请求`lib`文件的时候，会首先看看本地的缓存，如果缓存没有过期，并且名字和URL相同的话，就会使用本地缓存。这样就能减少浏览器对CDN的请求，加快脚本的加载过程。以下是同一个资源在使用缓存和不使用缓存下的速度差：

###### Chrome Dev Tool

我们可以使用 Chrome Dev Tool 的 Network 标签来对页面加载的一些网络情况进行研究分析，并提出改进开发实践的方案。Chrome Dev Tool 的 Network 标签如图。

###### 编码实践

样式表写到前面，让浏览器有时间提前去下载（这并不会阻塞HTML解析，反而会让样式表对象更快的构建出来）
阻塞DOM树构建的脚本放到页面后面，让DOM树先构建出来然后和提前下好的样式表构成渲染树先显示一部分

##### 参考书籍

[网络是怎样连接的]: http://www.ituring.com.cn/book/1758	"网络是怎样连接的"
[图解HTTP]: http://www.ituring.com.cn/book/1229	"图解HTTP"

# 网络安全

本章节内容主要是搭建一些关于安全的基本概念，从加密的原理到应用，到实际使用以及一些常见安全问题的认识。还捎带讲解了 ajax 和 jsonp 的基本原理。

# 一个设计良好API的分析

本章内容主要讲解了一个实例，来自 UBER 的 API 分析。以及粗略的了解了 百度短网址 iTunes Search GitHub API等一些常见 API 的使用。