# 网络基础知识

本章节的内容注重实际应用，通过讲解在用户从浏览器地址栏输入网址到浏览器渲染出页面的过程中发生了什么来穿插学习内容，达到学习以后可以掌握在开发中熟练使用 HOST 代理和抓包分析的目的。

### 一个最普通的请求的概览

#### HOST和DNS

我们来用一个图看看一个最普通的请求是怎么发生的。

由于我们的互联网是基于TCP/IP来构建的，所以浏览器在输入域名之后，其实浏览器并不知道你想访问的服务器到底是网络上的哪个设备，它必须要去找到这个域名对应的IP地址，然后把请求发送到这个IP地址上。

如图：浏览器查询域名与IP地址关系的服务器叫做DNS服务器，该服务器没有域名，直接以IP地址的形式保存在用户计算机的配置里面。

就这样吗？那原来还没有发明DNS服务器的时候，人们是怎么访问互联网的？

原来，在那时，人们维护一个叫做HOST的文件，在这个文件中，记录了当时为数不多的域名和它们对应IP的关系。（那么肯定有一些IP没有域名，那我们怎么访问它呢？我们可以通过在浏览器中直接输入IP地址的方式访问它们）

但是随着拥有域名的站点越来越多，大家的HOST文件都无法保证 1）同步更新，2）收录最新最完整的列表。这个时候有这么一种想法，能不能把这些HOST放到固定IP上，大家都去这个固定IP请求该文件呢？甚至，我们可不可以不请求整个庞大的文件，而是只让它告诉自己想要访问那个域名的IP就行了呢？这个就是我们现在DNS服务器的原理：我们让它告诉我们需要访问的域名的IP地址。我们就这样成功的把本地冗长的HOST文件移动到了一个公共服务器上。

虽然每个电脑本地的HOST文件的内容都没有了，但是这个机制还是留存着：操作系统会先去本地HOST查询域名，如果查到了，直接访问；如果没有查到，再去远程DNS查询。

理解了以上的内容我们来看看我们要学会的第一个技能：作为一个开发者，我们假如仍然想用真实的域名`welkin.online`去访问我们的开发机器上面的服务器`10.10.10.1`，那我们应该如何做呢？或者我们需要把一个开发用的域名如 `dev.welkin.online`绑定到自己开发用的机器`10.10.10.1`上呢？有多种方式：1）我们可以修改想要用来访问的计算机的HOST文件，让该域名指向开发机器；2）我们可以自己搭建DNS服务器，让想要访问的计算机的DNS设置为这个DNS服务，然后在DNS服务中将开发机器的IP与想要访问的域名进行绑定。

现在我们开始了手机页面的开发，这个时候我们想要用手机真机来调试，我们却发现，在现在的iOS手机上，我们是没有权限访问到HOST文件的。那我们只剩下自建一个DNS服务器了？其实并不是的，接下来我们来学习一种新的方式-**代理**

#### 什么是代理

代理就是用户A把所有的请求都通过一个外界的服务器B来完成对一些网站C的请求。从被请求的网站C来看，所有的请求就是来自B的IP，而不是A。那么这个和我们将手机的请求定位到开发机器上有什么关系呢？我们可以这么看看。在B服务器的HOST中将开发机器和相应域名绑定，这样被代理过来的流量走到B机器的时候，也会查询这个HOST，这样就能达成手机访问开发机器了。

PS：这个代理过程也可以全部发生在手机上，即AB都是我们的手机。有一些调试和代理iOS app，可以将手机所有的流量接管并且代理到指定的机器上，也可以在该APP内部将流量分流，将`dev.welkin.online`直接指向开发机器`10.10.10.1`如图：

#### 知识点总结

1. DNS服务：
2. HOST文件：

#### 课后思考题

```
1 在各大操作系统上，HOST文件都在什么目录？该文件的用户组权限是什么？
2 DNS协议的默认端口是什么？如何自己架设一个DNS服务器
3 画出代理模式的网络请求图
```


### 协议(protocol)、域名(host)、路径(path)、搜索(query)、请求方法(method)和头部字段

我们来看看在浏览器输入的内容：

http://welkin.online:8080/2017/05/?comment=0

以上的内容我们称作 URL 或者 URI （URL 和 URI的区别我们会附在结尾）。

我们来看看发出去的请求，用`plain text`来看是什么样的：

```http
GET /2017/05/?comment=0 HTTP/1.1
Host: welkin.online
Connection: Close
User-Agent: Paw/3.1.1 (Macintosh; OS X/10.12.5) GCDHTTPRequest
```

这个请求内容第一行的单词就是**请求方法**，这里我们使用了`GET`方法来请求资源；第一行方法后面的就是**请求路径**和**搜索**，我们在这里请求了`/2017/05/`这个路径的资源，并且给出了`comment=0`这个搜索条件；之后的行数里面都是头部字段，我们可以看到第二行是Host字段，第三行是Connection字段，第四行是User-Agent字段。下面我们来分析一下这几个要素：

#### 协议

这里的协议就是 `http://`。我们首先建立一个协议的概念：什么是协议？协议就是双方协定好了的一种数据的表达、通信或者编码方式。比如我们在桌面上新建一个空白的`.html`文件，然后右键使用浏览器打开，这个时候我们还会看到`http://`开头的协议吗？不会，我们会看到`file://`开头的协议，这就是`file`协议。那如果我们在浏览器地址栏中输入其他的协议呢？比如`smb://`,`ssh://`,`ftp://`会怎么样呢？

截图：

`smb://`,`ftp://`这两个协议都会弹窗提示我们是否打开`Finder.app`，而`ssh://`则会问我们是否要打开`终端.app`。**由此我们可知道在操作系统里面，不同的协议种类是对应到了不同的客户端软件的。**而网络浏览器主要对应的协议就是`http://`和`https://`（当然，也可以支持`file://`协议）。

而我们使用的HTTP协议，是一个文本传输协议（Hyper Text Tranfer Protocol），它直接传输文本内容，并且不保留客户端协议。

#### 域名

这里的主机名就是 `welkin.online`。它的作用是什么？由于使用互联网的用户越来越多我们的IP地址变得非常紧张，有的时候，我们不得不把好几个网站共享一个IP地址（即同一个物理服务器），这个时候我们把每个网站称为一个`虚拟主机`而把物理服务器称为`服务器`，然后使用诸如`nginx`来作为一个`http`服务软件。而域名在这里面除了能给DNS以查询IP的功效之外，还需要放在HTTP请求里面（host头字段中）方便服务器上的程序区分该请求究竟是请求该物理主机上哪个虚拟主机的。

#### 路径

这里的路径就是 `/2017/05/`，这里是告诉http服务器我们想要访问的文件基于网站根目录的位置。假设在Linux服务器上，网站的根目录是 `/www/`，那么我们在这里访问的目录就是`/www/2017/05/`。后来我们有了PHP等后端程序，这个时候，目录也可以并不真实存在，而是变成了`路由`。

#### 搜索

这里的搜索就是 `comment=0`，这个搜索是完全交给后端程序处理的。比如我们传递了一个`comment=0`，那么后端PHP程序就会去找这些博文中，评论数量等于0的返回。这个方法在 HTTP协议 0.9 版本的时候，是向后端传递信息的唯一方法，因为 HTTP 0.9 仅支持`GET`方法，并且不支持头部字段。 

#### 请求方法

请求方法，也叫做**HTTP动词**或者**HTTP谓词**我们这次请求是通过`GET`方法来请求的。那么是不是只有`GET`这种方法了呢？当然不是，常见的HTTP方法和它们的操作如下：

```
GET: 从服务端获取一个资源（不对对服务端的数据做修改）
POST:在服务端新建一个资源（会在服务端的数据新增记录）
PUT: 更新服务端的一个资源（会修改服务端的数据）
HEAD:只返回GET方法的头部
OPTION:询问服务端支持哪些HTTP方法
DELETE:将资源从服务端删除
```

而我们最常用的请求方法就是`GET`和`POST`方法。一般情况下，我们使用GET方法从服务端获取资源，如`HTML`文件，`CSS`文件，`JS`文件。而使用`POST`方法来传递一些表单给服务端。

##### 常见的误用

我们经常可以看见有的开发者在`GET`方法的搜索中传递参数（这很可能是从 HTTP 0.9 时代带来的坏习惯），以至于习惯了之后竟然将用户名和密码的明文通过`GET方法`来传输，造成严重的泄密事件。

我们来辨析一下这两个方法在传递参数时候的同异：

`GET`方法：参数直接写在URL中，通过URL query（搜索）来传递参数，在某些浏览器上会有长度限制，且传递的参数会在途经的路由设备上的日志记录下来，如果传递用户名等敏感信息会导致信息被截获的风险加大。

`POST`方法：参数写在请求的body中，可以传输的信息长度比`GET`方法要长，不会存在被路由设备记录下信息的风险。

##### 课外思考

Q：既然不能明文传输，那我们应该怎么处理用户登录的账号和密码呢？（答案见课程最后）


#### 头部字段

每一个请求都有头部字段，比如：Host，或者 Connection。头部字段附带了一些详细信息，比如用户想要访问的域名，或者本次访问的连接类型，或者用户使用的浏览器类型。更多关于HTTP头字段的信息可以在[维基百科](https://zh.wikipedia.org/wiki/HTTP头字段列表)中找到。在后面我们还会继续提到这个话题，所以这里就先不详细展开。

#### 小结

协议 -> 客户端与服务端协定的通信方式。

域名 -> 告知服务端的`http`服务软件我们访问的具体是哪个虚拟主机

路径 -> 告知后端程序我们想要访问的文件路径（该路径可以不存在，只要后端程序可以处理即可）

搜索 -> 告知后端程序我们想要查询的一个内容，后端程序进行计算后返回结果。

请求方法 -> 告知服务端我们想要进行的操作

### 请求发送到服务器之后发生了什么呢？

首先我们看看服务端的返回是什么样的：

```http
HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sun, 28 May 2017 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.welkin.online
Connection: keep-alive

<html>
	<head>
	</head>
	<body>
		Hello, world!
	</body>
</html>
```

这段返回的前面几行怎么看着这么眼熟呢？是不是和请求的头特别像？没错，这个就是`响应头`，第一行包括了HTTP版本和`HTTP状态码（HTTP Status Code）`（更多内容更可以参考[wikipedia](https://zh.wikipedia.org/wiki/HTTP状态码)），最后是`HTTP状态码信息`。

#### HTTP返回头

服务端返回的文件的头几行一直到第一个空行为止，都是HTTP返回头。它包含了一些必要的信息。它也由头行和后面跟随的HTTP头字段构成。头行包括HTTP协议版本，HTTP状态码，状态码信息。

##### HTTP状态码

HTTP状态码`的一些常见数值：

###### 1xx消息：

一般此类消息表示服务端已经收到了客户端的请求，需要继续处理。一般这个是临时响应。

###### 2xx成功：

表示请求已经被客户端成功接受并且处理。常见的有`200 OK`、`201 Created`、`202 Accepted`

###### 3xx重定向：

表示资源已经变更，需要客户端进一步操作，常见的有`301 Moved Permanently`、`302 Found`

###### 4xx客户端错误：

表示客户端的请求有问题，常见的有`400 Bad Request`、`401 Unauthorized`、`403 Forbidden`、`404 Not Found`、`405 Method Not Allowed`、`408 Request Timeout`

###### 5xx服务端错误：

表示服务端发生了错误，常见的有`500 Internal Server Error`、`502 Bad Gateway`、`503 Service Unavailable`、`504 Gateway Timeout`

以上只是列举了一些常见的状态码，更多详细的信息可以参考[维基百科](https://zh.wikipedia.org/wiki/HTTP状态码)

##### HTTP响应头字段

响应头的头字段也是用来描述一些不需要直接放到响应体中的信息。比如服务端使用的软件，或者响应的长度（字节数），但是最值得说的就是`Set-Cookie`字段（还有即将提到的`ETag`字段）：`Set-Cookie`是为了给HTTP这个**无状态协议**加上状态而提出来的一个内容。服务端在这里告诉客户端：“hi，下次你请求新资源的时候带上这个，我就认得你啦！”而客户端下次请求的时候带上了`Cookie: cookieFromServer`，就能让服务端辨识出自己的身份了。

那么`ETag`字段又是干什么的呢？这个字段反映了对于某个资源的某个特定版本的一个标识符，只要客户端发现了这个标识符没有发生变化，就不会再次和服务端请求这个资源，是我们用来提速的一个好东西。（后续在缓存策略中会有提及）。

那么回归正题，请求在服务器中，究竟是怎么走的呢？

#### 网页服务器和后端程序

网络请求打到服务器上之后，（如果是在网页服务器监听的端口上，比如80端口，的时候）首先会经过网页服务器，如果没有经过网页服务器监听的端口，那这个请求就会直接进入那个端口（比如说8080端口），如果这个端口是由后端服务器（如PHP，node.js）开启的，那个这些请求就会直接发送给后端程序。而进入网页服务器的请求，会按照网页服务器的配置来进行分流（如果在网页服务器上托管了多个后端程序，即托管了多个**虚拟主机**）

##### 小问题：为什么要使用HTTP服务器呢？或者说，它的好处在哪里呢？

##### 必备技能：

在平时开发中，如何学会给错误返回除错？

首先，我们要学会看请求是怎么被处理的。也就是说，这个请求究竟是首先被网页服务器处理了，还是直接发送到了后端程序？其次，我们再去看网页服务器和后端程序的日志文件。

# 网络安全

本章节内容主要是搭建一些关于安全的基本概念，从加密的原理到应用，到实际使用以及一些常见安全问题的认识。还捎带讲解了 ajax 和 jsonp 的基本原理。

# 一个设计良好API的分析

本章内容主要讲解了一个实例，来自 UBER 的 API 分析。以及粗略的了解了 百度短网址 iTunes Search GitHub API等一些常见 API 的使用。